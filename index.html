
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - buffer geometry custom attributes - particles</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	</head>
	<body style="background-color: #000000;">
		
        <div id="container"></div>

		<script type="x-shader/x-vertex" id="vertexshader">
			attribute float size;
			varying vec3 vColor;

			void main() {
				vColor = color;
				vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
				gl_PointSize = size * ( 300.0 / -mvPosition.z );
				gl_Position = projectionMatrix * mvPosition;
			}

		</script>

		<script type="x-shader/x-fragment" id="fragmentshader">
			uniform sampler2D pointTexture;
			varying vec3 vColor;
			
            void main() {
				gl_FragColor = vec4( vColor, 1.0 );
				gl_FragColor = gl_FragColor * texture2D( pointTexture, gl_PointCoord );
			}

		</script>

		<script type="module">

            import * as THREE from './libs/three.module.js';
            import { OrbitControls } from './libs/OrbitControls.js';
            import { ParticlePool } from './src/particlepool.js';
            import { Particle } from './src/particle.js';
            import { SoundHandler } from './src/soundhandler.js';
			import Stats from './libs/stats.module.js';

			var renderer, scene, camera, stats;

			var particleSystem, uniforms, geometry;

			var particles = 100000;
            var sh = new SoundHandler()
            var pp = new ParticlePool();
            var invMaxFps = 1/60;
            var frameDelta = 0;
            var clock = new THREE.Clock();


			init();
			animate();

            function init() {
                camera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 10000 );
                camera.position.x = -253;
                camera.position.y = 2793;
                camera.position.z = 947; 

                sh.Init();
                camera.add(sh.listener);

                scene = new THREE.Scene();

                uniforms = {

                    pointTexture: { value: new THREE.TextureLoader().load( "textures/sprites/spark1.png" ) }

                };

                var shaderMaterial = new THREE.ShaderMaterial( {

                    uniforms: uniforms,
                    vertexShader: document.getElementById( 'vertexshader' ).textContent,
                    fragmentShader: document.getElementById( 'fragmentshader' ).textContent,

                    blending: THREE.AdditiveBlending,
                    depthTest: false,
                    transparent: true,
                    vertexColors: true

                } );


                var radius = 200;

				geometry = new THREE.BufferGeometry();

				var positions = [];
				var colors = [];
				var sizes = [];

				var color = new THREE.Color();

				for ( var i = 0; i < particles; i ++ ) {
                    var p = new Particle();
                    p.Init(i);
                    pp.particles.push(p);
                    positions.push(0,0,0);
                    colors.push(0,0,0);
					sizes.push(0);
				}

				geometry.setAttribute( 'position', new THREE.Float32BufferAttribute( positions, 3 ) );
				geometry.setAttribute( 'color', new THREE.Float32BufferAttribute( colors, 3 ) );
				geometry.setAttribute( 'size', new THREE.Float32BufferAttribute( sizes, 1 ).setUsage( THREE.DynamicDrawUsage ) );

				particleSystem = new THREE.Points( geometry, shaderMaterial );

				scene.add( particleSystem );

                var planegeo = new THREE.PlaneGeometry( 5000, 5000, 1 );
                var matgeo = new THREE.MeshPhongMaterial( {color: 0x333333} );
                var plane = new THREE.Mesh(planegeo, matgeo);
                plane.rotation.x= -Math.PI/2;
                plane.position.y = 0;
                scene.add( plane );
                
               // var cubegeo = new THREE.MeshPhongMaterial( {color: 0x555588} );
               // var cube = new THREE.Mesh(new THREE.CylinderGeometry(100, 100, 100, 100), cubegeo);
               // cube.position.y = 50;
               // scene.add(cube);

                var texture = new THREE.TextureLoader().load( './mortar.png' );
                var cylmat = new THREE.MeshPhongMaterial( {map: texture });
                var cylgeo = new THREE.CylinderGeometry(10, 10, 30, 32, 32, true);
                var cyl = new THREE.Mesh(cylgeo, cylmat);
                cyl.position.y = 50;
                scene.add(cyl);

                var light = new THREE.AmbientLight( 0x404040 ); // soft white light
                scene.add( light );
                light = new THREE.HemisphereLight( 0xffffbb, 0x080820, 1 );
                scene.add( light );

				renderer = new THREE.WebGLRenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );

				var container = document.getElementById( 'container' );
				container.appendChild( renderer.domElement );

				stats = new Stats();
				container.appendChild( stats.dom );

                var controls = new OrbitControls( camera, renderer.domElement );
                controls.minDistance = 1;
				controls.maxDistance = 5000;
				controls.enablePan = true;

				//

				window.addEventListener( 'resize', onWindowResize, false );
                window.addEventListener('click', onClick, true);

			}
            function onClick() {
                 sh.Play("up1", 1.0);
                 pp.New({
                        effect: function(particle, dt, time) {
                            // Spin shell
                            particle.x += Math.sin(dt*time)*2;

                            pp.New({
                               x: particle.x,
                               y: particle.y,
                               z: particle.z,
                               mass: 0.002,
                               gravity: -0.5,
                               size: 20+Math.random()*40,
                               h: 1.0,
                               s: Math.random(),
                               l: 1.0,
                               life: Math.random()*2,
                               decay: 50,
                            });
                        },
                        x: 100-Math.random()*200,
                        z: 100-Math.random()*200,
                        y: 10,
                        size: 100,
                        mass: 0.5,
                        vz: 0,
                        vx: 0,
                        vy: 10+Math.random()*5,
                        h: 0.9,
                        s: 0.5,
                        l: 0.5,
                        life: 5+Math.random()*5,
                        decay: 10+Math.random()*20,
                        condition: function(particle, dt, time) {
                            return particle.vy <= -Math.random()*20? true:false;
                        },
                        action: function(particle, dt, time) {
                            sh.Play("boom1", 1.0, false);
                            for (var i = 0; i < 300; i++) {
                                pp.New({
                                   x: particle.x,
                                   y: particle.y,
                                   z: particle.z,
                                   size: Math.random()*50,
                                   mass: 0.5,
                                   gravity: -0.5,
                                   vy: 0.5-Math.random(),
                                   vx: 0.5-Math.random(),
                                   vz: 0.5-Math.random(),
                                   h: 1.0,
                                   s: 1.0,
                                   l: 1.0,
                                   r: 1.0,
                                   g: 1.0,
                                   b: 1.0,
                                   life: 0.1+Math.random()*2.5,
                                   decay: Math.random()*50,
                                });
                            }
                            var grav = -1-Math.random()*2;
                            var radius = 100;
                            for (var i = 0; i < 300; i++) {
                                var mx = Math.sin((Math.PI*2) * (i/300))*5;
                                var mz = Math.cos((Math.PI*2) * (i/300))*5;
                                pp.New({
                                   effect: function(particle, dt, time) {
                                        if (this.vy <= 0) {
                                            particle.x += Math.sin(Math.PI*2*time)*Math.random()*3;
                                            particle.z += Math.sin(Math.PI*2*time)*Math.random()*3;
                                        }
                                        if(Math.random() < 1/particle.life) {
                                           pp.New({
                                              x: particle.x,
                                              y: particle.y,
                                              z: particle.z,
                                              mass: 0.002,
                                              gravity: -0.5,
                                              size: 20+Math.random()*40,
                                              h: 1.0,
                                              s: Math.random(),
                                              l: 1.0,
                                              life: Math.random(),
                                              decay: 50,
                                           });
                                   }
                                   },
                                   x: particle.x,
                                   y: particle.y,
                                   z: particle.z,
                                   size: Math.random()*500,
                                   mass: 0.001,
                                   gravity: grav,
                                   // TBD: Use tan/sin to get side effect.
                                   vy: 10-Math.sin(Math.PI*2*i)*10, //Math.random()*4,
                                   vz: mz, //Math.random()*10,
                                   vx: mx, //Math.random()*10,
                                   r: Math.random(),
                                   g: 0.1,
                                   b: 0.2,
                                   h: 0.9,
                                   s: Math.random(),
                                   l: 0.5,
                                   life: 0.1+Math.random()*3,
                                   decay: Math.random()*100,
                                });
                            }
                          }
                        });
            }

			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
			}

			function animate() {
				requestAnimationFrame( animate );
				render();
				stats.update();
			}

			function render() {
				var time = Date.now() * 0.005;
                var delta = clock.getDelta();
                frameDelta += delta;

                while(frameDelta >= invMaxFps) {

				     var sizes = geometry.attributes.size.array;
				     var colors = geometry.attributes.color.array;
				     var positions = geometry.attributes.position.array;
                     
                     var alive = 0;
            
				     for ( var i = 0; i < particles*3; i +=3 ) {
                        var pos = i/3 | 0;
                        if (!pp.particles[pos].alive) {
                            continue;
                        }
                        alive++;

                         pp.particles[pos].Update(delta, time);

                         positions[i] = pp.particles[pos].x;
                         positions[i+1] = pp.particles[pos].y;
                         positions[i+2] = pp.particles[pos].z;
				         
                         sizes[pos] = pp.particles[pos].size;

                         colors[i] = pp.particles[pos].color.r;
                         colors[i+1] = pp.particles[pos].color.g;
                         colors[i+2] = pp.particles[pos].color.b;
                      }

			          geometry.attributes.size.needsUpdate = true;
			          geometry.attributes.position.needsUpdate = true;
			          geometry.attributes.color.needsUpdate = true;

                    //  camera.translateX(delta*100);
                      //camera.position.x = 500 * Math.sin( THREE.Math.degToRad( time ) );
                      //camera.position.y = 500 * Math.sin( THREE.Math.degToRad( time ) );
                      //camera.position.z = 900 * Math.cos( THREE.Math.degToRad( time ) );
                      //camera.lookAt( scene.position );
                      frameDelta -= invMaxFps;
                }

				renderer.render( scene, camera );

			}

		</script>

</body>
</html>
